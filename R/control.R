#' Control site names
#'
#' This function ensures site names conform to a controlled vocabulary.
#' It compares a vector of names to a thesaurus of variant names, misspellings
#' and character encoding inconsistencies and replaces matches with a canonical
#' form.
#'
#' @param x Character vector of site names.
#' @param quiet Logical. If `TRUE`, suppresses messages about replaced values.
#'  Default: `FALSE`.
#'
#' @details
#' Elements of `x` are matched to the site name thesaurus using the following
#' rules (in order of priority):
#'
#' 1. Exact matches to a variant name in the thesaurus
#' 2. Matches if non-ASCII characters are substituted for another a character
#'    (e.g. "Catalhoyuk" → "Çatalhöyük")
#'
#' Ambiguous site names—elements of `x` that match multiple thesaurus entries—
#' will cause an error.
#'
#' @return
#' `x` with elements matched to the thesaurus replaced by their canonical forms.
#'
#' Unless `quiet = TRUE`, the function also prints a list of values that were
#' changed. A warning will be issued if elements of `x` were not matched to the
#' thesaurus (regardless of the `quiet` argument).
#'
#' @family controlled vocabulary functions
#' @export
#'
#' @examples
#' sites <- c("Catalhoyuk", "Tepe Ganj Dareh", "Jericho")
#' swap_control_site_name(sites)
swap_control_site_name <- function(x, quiet = FALSE) {
  # Uses internal dataset `swap_site_name_thesaurus`
  # Generated by data-raw/swap_site_name_thesaurus.R
  thesaurus <- dplyr::transmute(
      swap_site_name_thesaurus,
      .data$canon,
      exact_match = .data$variant,
      ascii_match = stringr::str_replace_all(.data$variant, "[^[:ascii:]]", "."),
      ascii_match = paste0("^", .data$ascii_match, "$")
    )

  # Match x to thesaurus
  tibble::tibble(x = x) %>%
    dplyr::left_join(dplyr::select(thesaurus, .data$canon, .data$exact_match),
                     by = c("x" = "exact_match"), keep = FALSE) %>%
    dplyr::rename(exact_match = .data$canon) %>%
    fuzzyjoin::regex_left_join(dplyr::select(thesaurus, .data$canon, .data$ascii_match),
                               by = c("x" = "ascii_match")) %>%
    dplyr::select(-.data$ascii_match) %>%
    dplyr::rename(ascii_match = .data$canon) %>%
    dplyr::mutate(canon = dplyr::coalesce(.data$exact_match, .data$ascii_match)) ->
    y

  # Check for ambiguous matches
  # Errors here could be a problem with the thesaurus. Check for:
  # * Duplicate entries
  # * Variants that only differ by substitution of a non-ASCII character
  if (length(x) != nrow(y)) {
    rlang::abort("`x` matched multiple thesaurus entries.",
                 class = "swap_control_error")
  }

  # Message for replaced names
  # TODO: Group messages by match type?
  if (!quiet) {
    y %>%
      dplyr::filter(.data$x != .data$canon) %>%
      dplyr::distinct() %>%
      glue::glue_data('"{x}" \u2192 "{canon}"') %>%
      magrittr::set_names(rep("i", length(.))) %>%
      c("Replaced site names:", .) %>%
      rlang::inform()
  }

  # Warning for unmatched names
  y %>%
    dplyr::filter(is.na(.data$exact_match), is.na(.data$ascii_match)) %>%
    dplyr::distinct() %>%
    glue::glue_data('"{x}"') %>%
    magrittr::set_names(rep("x", length(.))) %>%
    c("Site names not matched in thesaurus:", .) %>%
    {if (length(.) > 1) rlang::warn(.)}

  # Return
  dplyr::coalesce(y$canon, y$x)
}
